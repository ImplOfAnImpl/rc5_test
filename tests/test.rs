use std::ops::DerefMut;

use rc5_test::rc5::*;

fn test_enc_dec<F: Flavor>(key: &[u8], num_rounds: u8, pt: &[u8], expected_ct: &[u8]) {
    let cypher = Rc5Cypher::<F>::new(key, num_rounds);

    let mut block = pt.to_vec();

    cypher.encrypt_block(block.deref_mut().into());
    assert!(&block[..] == &expected_ct[..]);

    cypher.decrypt_block(block.deref_mut().into());
    assert!(&block[..] == &pt[..]);
}

#[test]
fn test16() {
    test_enc_dec::<Flavor16>(
        &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07],
        16,
        &[0x00, 0x01, 0x02, 0x03],
        &[0x23, 0xA8, 0xD7, 0x2E],
    );
}

#[test]
fn test32() {
    test_enc_dec::<Flavor32>(
        &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
        12,
        &[0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77],
        &[0x2D, 0xDC, 0x14, 0x9B, 0xCF, 0x08, 0x8B, 0x9E],
    );

    test_enc_dec::<Flavor32>(
        &[0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00, 0x95, 0x2C, 0x49, 0x10, 0x48, 0x81, 0xFF, 0x48],
        12,
        &[0xEA, 0x02, 0x47, 0x14, 0xAD, 0x5C, 0x4D, 0x84],
        &[0x11, 0xE4, 0x3B, 0x86, 0xD2, 0x31, 0xEA, 0x64],
    );

    test_enc_dec::<Flavor32>(
        &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
        12,
        &[0x96, 0x95, 0x0D, 0xDA, 0x65, 0x4A, 0x3D, 0x62],
        &[0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77],
    );

    test_enc_dec::<Flavor32>(
        &[0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00, 0x95, 0x2C, 0x49, 0x10, 0x48, 0x81, 0xFF, 0x48],
        12,
        &[0x63, 0x8B, 0x3A, 0x5E, 0xF7, 0x2B, 0x66, 0x3F],
        &[0xEA, 0x02, 0x47, 0x14, 0xAD, 0x5C, 0x4D, 0x84],
    );
}

#[test]
fn test64() {
    test_enc_dec::<Flavor64>(
        &[
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
            0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        ],
        24,
        &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
        &[0xA4, 0x67, 0x72, 0x82, 0x0E, 0xDB, 0xCE, 0x02, 0x35, 0xAB, 0xEA, 0x32, 0xAE, 0x71, 0x78, 0xDA],
    );
}

#[test]
fn test_zero_key_size() {
    // Edge case - key with zero length.
    // I couldn't find any reliable test vectors for this case, so here I only check that it does something
    // without failing.

    let pt = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77];

    let cypher = Rc5Cypher32::new(&[], 8);

    let mut block = pt.clone();

    cypher.encrypt_block((&mut block).into());
    assert!(&block[..] != &pt[..]);

    cypher.decrypt_block((&mut block).into());
    assert!(&block[..] == &pt[..]);
}
